# Reactive 宣言词汇表

* [异步的](#异步的)
* [背压](#背压)
* [批处理](#批处理)
* [组件](#组件)
* [委派](#委派)
* [可伸缩性（与可扩展性相对照）](#可伸缩性)
* [失败（与错误相对照）](#失败)
* [隔离（以及包含）](#隔离)
* [位置透明性](#位置透明性)
* [消息驱动（与事件驱动相对照）](#消息驱动)
* [非阻塞的](#非阻塞的)
* [协议](#协议)
* [复制](#复制)
* [资源](#资源)
* [可扩展性](#可扩展性)
* [系统](#系统)
* [用户](#用户)

## <a name="异步的"></a>异步的
牛津词典把“异步的”定义为**“不在同一时刻存在或发生的”**。在本宣言的上下文中，我们想表达的意思是：对一项请求的处理过程可以发生在任意时间点，有时候请求已经从客户端发送到服务端了，其处理过程还未开始。这时候，客户端无法直接观察到这项请求在服务端的执行过程，也无法与执行过程保持同步。作为异步的反义词，同步是指客户端暂停执行，直到服务端已经把请求处理完毕，才继续自己的执行过程。

## <a name="背压"></a>背压
当一个[组件](#组件)需要挣扎着保持正常运行时，[系统](#系统)作为整体也需要以某种可感知的方式做出响应。让一个承受压力的组件灾难性地停止工作，或在失控的状态下丢弃消息，是不可接受的。因为它既不能应对，又不能停止工作，所以就该与上游的组件沟通，说明自己正在承受压力的事实，并使上游组件减少负载，这就是背压。背压是一种很重要的反馈机制，它允许系统在面对负载时优雅地做出响应，而不是被负载压垮。背压可以层层升级，直至到达用户面前，这种情况下系统的响应能力可能会降级，但这种机制可确保系统在承受负载时表现出一定的韧性，并能对外提供信息，使系统有机会申请更多有助于分散负载的资源，参见[弹性(#弹性)。

## <a name="批处理"></a>批处理
当今的电脑被优化为重复处理同一项任务：指令缓存和分支预测增加了每秒钟内可以被处理的指令数，但时钟频率却保持不变。这就意味着把不同的任务一个接一个地快速提交给同一个 CPU 内核并不能受益于 CPU 的最大性能，而另一种方式就能达到目的：只要有可能我们就该对程序的结构做出调整，使其执行过程在不同任务之间交替的动作不那么频繁。这意味着成批次地处理一系列数据元素，或者在专属的硬件线程上执行不同的处理步骤。
同样的推理也可应用于那些需要同步和协调的外部[资源](#资源)的使用。当命令来自一个单独的线程（因此也是同一个 CPU 内核）而不是争夺来自多个内核的带宽时，持久性存储设备的输入/输出带宽将能得到显著的提升。使用单一的入口具有额外优势：对 CPU 的操作可以被重新排列，以更好地适应针对这类设备的优化的访问模式（当前的存储设备的线性访问性能优于随机访问）。
更进一步，批处理还带来了分摊高消费操作成本的机会，输入/输出或昂贵的计算过程都属于这样的高消费操作。举例来说，把多个数据项打包进同一个网络包或者磁盘块，就能提高效率并减少高消费操作。

## <a name="组件"></a>组件
在使用组件这个术语的时候，我们是在描述一种模块化的软件架构，模块化是一种非常旧的观念，可以参考 [Parnas（1972）](https://www.cs.umd.edu/class/spring2003/cmsc838p/Design/criteria.pdf)中的例子。我们使用“组件”这个术语是因为它与隔间很近似，暗示每个“组件”都是自包含的，被封装的，并且与其它组件相互[隔离](#隔离)的。此概念首先适用于描述系统的运行时特征，但它也通常也会在源代码的模块结构中得到反映。正如不同的组件可能会利用同一个软件模块执行常见任务，定义每个模块顶层行为的程序代码本身也是一个模块。组件的边界常常与问题领域的[有界上下文](http://martinfowler.com/bliki/BoundedContext.html)相匹配。这意味着系统设计倾向于反映问题领域，并且因此能在保持隔离的情况下，相对容易地进行演化。消息协议在不同的有界上下文（组件）之间提供了一种自然的映射和沟通层次。

## <a name="委派"></a>委派
把一项任务[异步地](#异步的)委派给另一个组件处理，意味着这项任务的执行过程将会在那个组件的上下文中发生。这个被委派的上下文将会继续运行在另一个错误处理上下文中，或另一个线程、进程、网络节点中，这里仅列出几种可能性。委派的目的是把一项任务的处理责任移交给另一个组件，这样发起委派的组件就可以转而执行其它处理任务；或者，当它需要在委派之后做进一步善后处理——如错误处理或进度汇报时，转而观察被委派的任务的进展状况。

## <a name="可伸缩性"></a>可伸缩性（与可扩展性相对照）
可伸缩性的意思是，系统能自动做出吞吐量的升级或降级动作，以便在资源被加入或移除时，自动地满足变化的需求。系统需要满足[可扩展性](#可扩展性)，才能允许运行期间动态地加入或移除资源，实现可伸缩性带来的效益。由此可见，可伸缩性建立在可扩展性之上，并且在此基础上增减了动态[资源](#资源)管理的概念。

## <a name="失败"></a>失败（与错误相对照）
失败是一个发生在当前服务中的意外事件，它会阻止服务继续正常工作。失败通常会阻止当前的客户请求的响应，并且很可能也会阻止所有后续的响应。这与错误形成了对照，错误是一种可预料并可用代码去应对的情况——例如在输入检查阶段发现的错误，作为常规的消息处理的一部分，系统可以与客户沟通说明这类错误。与错误不同，失败是意外发生的，而且需要对[系统](#系统)做出干预，才能恢复到失败前相同级别的运行状态。这么说并不意味着失败总是致命的，而是意味着系统的某些能力在失败发生后可能会下降。错误是正常操作过程中预料之内的，可以立刻得到处理，而且系统在错误发生后能够以原来的能力水平继续运作。

失败的例子包括硬件失灵，因致命的资源耗尽导致处理过程中止，因程序缺陷导致崩溃的内部状态等。
