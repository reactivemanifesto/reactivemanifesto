The Reactive Manifesto
----------------------


在不同领域的人们在探索发现一些看起来一样的模式。这些系统更加牢靠，更加有弹性，更加可变通、更加能适应现在的需求。


这些变化正在发生，因为近年来应用需求正发生显著的变化。几年前一个大型应用需要几十台服务器，几秒的响应时间，离线维护些许时辰和上GB的数据。现在应用正在从部署到手机，乃至云端运行着上千的多核CPU的集群。用户期待毫秒的响应以及保持在线的状态。数据达到了PB级别。昨天的架构无法满足如今的需求。

我们相信一个连贯一致的方法是需要的：我们需要系统时相应、有适应性的、弹性的以及消息驱动的。我们称之为反射式系统。


反射式构建的系统更加可变通,松耦合以及[可扩展](/glossary#Scalability)。这时的他们更佳简单构建和经得起变化，当[失败](/glossary#Failure)发生，他们以一种优雅的姿态面对而非面对灾难。反射式系统更加具有响应性，给[用户](/glossary#User)以有交互性的反应。

*反射式系统是:*


* <a name="Responsive"></a>**反射性的**: 这个[系统](/glossary#System) 在一定时间内以各种可能的方式来反射。反射性是易用性和可用性的奠基石，更甚的是，这意味着问题可以更快被定位以及更有效处理。反射式系统专注于提供一个更快和持续不断的响应，建立更可草的上层基石这样可以提供一个不断可靠的服务。这种不断的行为相应简化了错误处理，给终端用户的信心，更加会使用这样的系统。

* <a name="Resilient"></a>**适应多变的**: 系统对[失败](/glossary#Failure)有响应性 。这不仅适用于高可用的重要的系统，不持续的系统都会因为失败而变得没有响应。持续不断是通过[自我复制](/glossary#Replication)来实现的。. This applies not only to highly-available, mission critical systems — any system that is not resilient will be unresponsive after a failure. Resilience is achieved by [replication](/glossary#Replication), 控制，隔离，代理来实现的。错误是在[Component](/glossary#Component)里包含的，组件之间相互隔离，当错误发生的时候，是一小部分受害而不会危及整个系统。每一个组件的恢复是通过别的组件来恢复的高可用是通过需要的时候自我复制来达到的。一个组件的客户不因为处理错误而阻碍。

* <a name="弹性"></a>**弹性**: 这个系统在各种负载下保持相应性。反射式系统可以通过增加或者减少分配给服务这些输入的[资源](/glossary#Resource)来适应变化的输入。这意味设计他们不需考虑竞争点活着中心的瓶颈，得到的是可以分片的或者复制的组件，以及可分发的输入。反射式系统通过提供相关的实时性能数据监控来支持可预测的，反射性的，可扩展的算法。他们通过一种在硬件软件平台上的有成本价值的方式来得到[弹性](/glossary#Elasticity)。

* <a name="消息驱动"></a>**消息驱动**: 反射式系统依赖于消息传递来建立一种组件之间的边界来确保低耦合，隔离以及[位置透明](/glossary#Location-Transparency)。这种边界也提供了将错误作为消息代理给别人的方法。使用专门的消息系统使得载控管理，弹性以及流控制变得可能。这些可以用打磨消息队列或者使用[back-pressure]的方法来得到。位置透明的消息使得在不同环境下比如跨集群或者在一个localhost管理失败异常变得可能。[非阻塞](/glossary#Non-Blocking)的IO使得接受者只在活跃的时候才会消耗资源，确保了更低的系统开销。

大型系统是由较小的组成的，因此依赖于他们的组成部分的反射属性。这意味着反射系统将设计原则应用于他的系统这样她们的属性就可以应用在各种状况下，这样她们就可以组合起来。这世界上最大的系统依赖于基于这些属性做成的架构，每天服务着上亿人。是时候来有意识的从开始就应用这些设计原则而不是每次来重复发现他们。

[宣言](http://www.reactivemanifesto.org/#sign-button)
