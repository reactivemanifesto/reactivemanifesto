反应式宣言
---------

在不同的领域深耕的各个组织都独立地发现了一种看起来相同的构建软件的模式。
这些系统更加的健壮、更加弹性、更加灵活并能够更好地满足现代化的需求。

这些变化方兴未艾，
因为最近这些年的应用程序需求发生了急剧地变化。
仅在几年以前，
一个大型应用程序拥有数十台服务器、
数秒的响应时间、
数小时的维护时间以及GB级别的数据。
而今天，
应用程序被部署到了从移动设备到运行着数以千计的多核心处理器的云端集群的所有形态上。 
用户期望毫秒级的响应时间以及100%的正常运行时间。
以前的软件架构已经根本无法满足现代的需求了。

我们认为需要一种同调的系统架构方法，
并且我们认为所有必要的方面都已经被单独地认识到了：
我们需要具有响应式、弹性、适应性以及消息驱动的系统。
我们称之为反应式系统。

被构建为反应式的系统更加灵活、松散耦合度并且[可伸缩](/glossary#可伸缩性)。
这使得他们可以更加容易地被开发以及改变。
他们对系统的[失败](/glossary#失败)更加地包容，
当失败着实发生时，
他们将用优雅而不是灾难性的方式来应对失败。
反应式系统具有极高的响应性，能够给予[用户](/glossary#用户)有效的交互反馈。

**反应式系统具有：**

* <a name=""></a>**响应式**：
只要有可能，[系统](/glossary#系统)就会及时地做出响应。
响应能力是可用性和实用性的基石，
但是更加重要的是，
响应能力意味着可以快速地检测到问题并且行之有效地解决它。
响应式系统专注于提供快速而一致的响应时间，
确立可靠的上界，
从而提供一致地服务质量。
这种一致的行为反过来有简化了错误处理、
建立了最终用户的信任、
并鼓励他们进行进一步的交互。

* <a name="弹性"></a>**弹性**：
系统在出现[失败](#失败)时依然保持响应式。
这不仅适用于高可用性、任务关键型系统——任何不具备弹性的系统都将会在失败之后丢失响应式。
弹性是通过[复制](/glossary#复制)、遏制、[隔离](/glossary#隔离)以及[委派](#/glossary#委派)来实现的。
失败被包含在了每个组件内部，
和其他组件相互隔离，
从而确保了系统的各个部分能够在不危及整个系统的情况下失败和恢复。
每个组件的恢复都被委派给了另外一个（外部的）组件，
并在必要时通过复制来实现高可用性。
（因此）组件的客户端（也就）没有处理组件失败的负担。

* <a name="适应性"></a>**适应性**：
系统在不同的工作负载之下依旧保持响应式。
反应式系统可以通过增加或者减少分配给服务于系统输入的资源来响应输入速率的变化。
这意味着设计上并没有争用点和中心化的瓶颈，
导致了分片或者复制组件并在他们之间分配输入的能力。
通过提供相关的实时性能测量信息，
反应式系统可以支持预测式以及反应式伸缩算法。
他们在日常的硬件以及软件平台上实现了成本高效的弹性。

* <a name="消息驱动"></a>**消息驱动**：
反应式系统依赖[异步的](/glossary#异步的)[消息传递](/glossary#消息驱动)来建立组件之间的边界，
以确保松散耦合、隔离以及[位置透明性](/glossary#位置透明性)。
这一边界还提供了将[失败](/glossary#失败)委派出去方式。
使用显式的消息传递，
通过在系统中形成并监视消息流队列，并在必要的时候使用[回压](/glossary#回压)
从而实现了负载管理、弹性以及流控制。
使用位置透明的消息传递作为通信的手段，
使得跨集群或者在单个主机中使用相同的构造管理失败成为了可能。
非阻塞的通信使得接收者只在活动的时候消耗资源，
从而带来更少的系统开销。


大型系统是由较小的系统所构成的，
因此依赖于他们的构成部分的反应式特性。
这意味着，
反应式系统应用了一些设计原则，
因此这些属性也适用于所有级别的伸缩，
使得他们可以混搭。
世界上最大型的系统依赖于基于这些属性的架构，
并每日服务于数十亿的人们的需求。
现在是时候从一开始就有意识地应用这些设计原则而不是每次都重新发现他们了。

[签署这份宣言](http://www.reactivemanifesto.org/#sign-button)
