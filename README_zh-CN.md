反应式架构宣言
----------------------

[签署宣言](http://www.reactivemanifesto.org/)

##对快速反应的需求
对应用的需求在近十年发生了显著的变化。仅仅几年前，大型应用也只有几十台服务器、秒级响应时间、小时级离线维护，以及G级数据量。今天，应用几乎部署在一切设备上，从移动设备到数以千计的多核的云端集群机器。在客户端，智能机快速发展和“物联网”兴起的趋势，必将大幅提高系统要处理的并发用户数。用户期待毫秒甚至微秒级响应时间并且全天候在线。数据量也需要扩张到P级。

最初属于创新的互联网驱动的公司——像GOOGLE或TWITTER——的领域，如今更多行业也正面临这种应用需求，财务和电信行业是最先采用新实践来满足新需求的，其他行业逐渐跟进。

需求的演进呼唤新的技术。曾经的解决方案强调受管的服务器或容器，通过购买大型服务器和多核处理器实现系统扩容的目的，包括购买额外的服务器来运行复杂、低效却昂贵的专门的解决方案。

不过现在一种新的架构应运而生，它把已有元素和新的元素整合起来，让开发者进行概念建模并构建应用以满足今天的需要。我们称之为反应式应用。这种架构让开发者构建事件驱动的、可伸缩的、具有弹性的和快速响应的系统：用实时响应提供快速响应的用户体验，后台则由可伸缩的和具有弹性的应用栈支撑，能够部署到多核和云计算结构中。反应式架构宣言描述这些做到敏锐反应所需的关键特性。

##反应式应用
Merrian-Webster将“反应的”定义为快速响应请求，也就是说，系统的组件处于活跃状态并且总是能够接收事件。这个定义抓住了反应式应用的本质：
- *对事件的反应*：事件驱动的本质使系统具有以下品质：
- *对负载的反应*：专注于可伸缩性以避免争用共享资源
- *对失效的反应*：构建弹性的系统，能够从各种失效级别恢复过来
- *对用户的反应*：不管负载如何都确保给用户以拿得出手的响应时间

每个反应都是反应式应用的本质特征。和标准层次化的应用架构不大一样，这些特征是互相依存的。它们描述了应用于整个技术栈的设计属性。

![fig. 1 响应式特性](images/stack.png)

接下来的内容我们会对这四个特征做深入的探讨，看看它们是怎样互相关联起来的。

##事件驱动
###为什么重要？
基于异步通信的应用实现了松藕合设计，比纯粹基于同步方法调用的系统肯定好的太多。发送者和接收者的实现不必考虑事件传递的细节，接口只须专注于通信内容。其结果，实现易于扩展、演进和维护，给你更大灵活性并减小维护成本。

异步通信的接收者在事件发生或收到消息以前能够保持休眠状态，因而事件驱动的方法可以高效利用资源，允许大量接收者共享单个硬件。比起传统的基于阻塞同步通信的应用来，非阻塞应用在高负载下仍然能做到短时延和高吞吐量。结果自然就是更低的运维成本、增长的PV和更嗨的终端用户。

###关键构件
在事件驱动应用中，组件通过生产和消费事件进行交互。事件包含描述业务的各种具体信息。事件驱动的系统应该依赖推送而不是拉取或轮询。也就是说，推送数据给消费者，而不是让消费者不停轮询等待数据造成资源浪费。
- 事件的异步发送——也被称为消息传递，意味着应用可以被设计成高度并发的，无须修改就可以利用多核硬件。任意一个CPU核都能处理消息事件，因而并行化就有机会显著提升性能。
- 非阻塞意味着即使在失效和突发流量的场景下，应用仍然能够全天候持续天候响应。实现这样的目标不仅不必独占资源，如CPU、MEM和IO，而且可以尽快释放资源。因此，应用既能降低时延，提高吞吐量，又能更好伸缩。

像J2EE之类的传统服务端架构依赖于共享的可变状态和单线程上的阻塞操作，这加大了需求变更时伸缩系统的难度。共享的可变状态要求同步，这又引入了难以预料的复杂度和不确定性，使程序代码难于理解和维护。阻塞资源使用线程又加大了唤醒成本。

解藕事件的产生和处理，让平台来处理同步细节和事件在线程间的分发，基于平台抽象，从而使编程专注在业务流程的层面。你仅须考虑系统内事件传递和组件如何交互，而不是浪费在线程和锁之类的低级原语上。

事件驱动的系统能够让组件和子系统进行松藕合。我们将看到，这种间接的性质，是达成可伸缩性和弹性的前提条件之一。通过去除组件间复杂的和强相关的依赖，扩展事件驱动的应用对已有系统的影响很小。

应用一旦承担起高性能和高伸缩性的要求，就很难预见哪儿会产生瓶颈。因此，采用异步的非阻塞的整体方案非常重要。在典型的应用结构中，这意味着从UI层的用户请求（在浏览器、REST客户端或其他客户端中），到web层解析和分发请求，到中间件层的服务组件（包括缓存和更下层的DB），都要采用基于事件驱动的设计。如果有任何一层不采用，如阻塞调用DB、依赖共享的可变状态、调用高成本阻塞操作，那么整个链路就不能正常工作，导致用户不得不忍受增加的时延和降低的伸缩能力。

应用必须*从头到脚都是反应式的*。

消除全链路上薄弱环节的必要性，在[阿德姆斯定律] (http://en.wikipedia.org/wiki/Amdahl's_law)中作了很好的说明。根据维基百科的解释是这样的：
> 提速并发计算环境下使用多处理器的应用，受限于程序的顺序化分片。举个例子，无论使用多少处理器，如果程序的95%能够被并行化，那么并发计算环境下该程序提速将达到理论最大值，即20倍。如下图所示。

![fig. 2 阿德姆斯定律](images/amdahl.png)

##可伸缩的
###为什么重要？
Merrian-Webster定义“可伸缩的”为：能够轻松被扩展或按需升级。可伸缩的应用能够根据其使用情况被扩展而无显著的性能下降。增加应用的弹性可以达到这个目的，按需放大或缩小（增加或删除节点）。另外，架构使应用易于并行扩展或收缩（将应用部署到CPU更多或更少的节点上）。弹性使云计算环境下应用的运维成本的最小化成为可能，使你从“仅为使用付费”模式中受益。

可伸缩性也有助于管理风险。承载用户负载的硬件过少，会导致用户不满和流失。硬件和运维人员过多，空载又会带来不必要的花费。可伸缩的方案还减轻了因应用无法利用新硬件而不得不提前报废的风险。我们将看到，下一个时代成百上千的硬件线程，利用新硬件的潜能要求应用在很细的粒度级别具有可伸缩性。

###关键构件

基于异步消息传递的事件驱动的系统提供了可伸缩性的基础。组件、子系统之间的松藕合、地域无关性，使得系统可以在同一语义的编程模型下扩展到多个节点。增加组件的更多实例就可以增加系统处理事件的容量。从实现层面来说，使用多核放大或使用更多节点扩展，没有区别。应用的拓扑结构转变为部署决策，这可以由配置或响应应用使用情况的运行时自适应算法来表述。我们称之为[地域透明性](http://en.wikipedia.org/wiki/Location_transparency)。

目标不是实现透明的分布式计算、分布式对象或类RPC通信（业界曾经试图这么做并且被证明失败了），理解这一点非常重要。真正的目标是，我们需要拥抱网络，通过在编程模型中使用异步消息传递来直接表现网络。真正的可伸缩性很自然地涉及分布式计算和节点间通信，意味着要穿透网络，这是我们所知道的[内在不可靠性](http://aphyr.com/posts/288-the-network-is-reliable)。因此，在编程模型中显式建立网络编程的规约、平衡原则和失效场景是很重要的，而不是将它们隐藏在有漏洞的抽象层之后试图简化事物。其结果，提供编程工具（封装分布式环境下典型问题解决办法的通用构建块）同等重要，和达成共识或消息抽象的机制一样，它提供了更高程度的可靠性。

##弹性
###为什么重要？
应用停服是损害业务的主要问题之一。通常意味着操作停止，业务收益流中断。也会造成客户的不爽和坏名声。而这又会更严重地损害业务。令人吃惊的是，应用的弹性被广泛忽略或仅仅翻新一些临时技术来解决。这通常意味着使用一些过粗粒度的工具在错误的粒度级别去解决弹性问题。常见的技术是使用应用服务集群来恢复运行时和服务器的失效。不幸的是，服务器故障恢复的开销特别大，并且也很危险，还可能引起雪崩，造成整个集群失效。原因是，应该使用组件级细粒度的弹性而不是用错误的粒度级别进行失效管理。

Merrian-Webster定义的弹性是：
- *物体或对象回复原形的能力*
- *从困难中快速恢复的能力*

在反应式应用中，弹性不是事后的，而是设计一开始就要考虑的部分。在编程模型中提供办法应对和管理失效，把失效管理当作头等重要的构件。其结果，应用具有高强度的容灾能力，失效能被有效hold住，并且在运行时自我修复。传统失效处理因大而无当（大到节点备份、切换与重起，小到处处捕获与处理异常）不能实现这个目标。你要么是疲于处理异常，要么是建立整个应用实例的切换机制。

###关键构件
为了管理失效，我们需要用隔离的办法，因而失效不会传播给其它正常工作的组件。同时监控失效，把它控制在失效上下文以外的安全点上。跃入脑海的一种模式是[隔间模式](http://skife.org/architecture/fault-tolerance/2009/12/31/bulkheads.html)，下图作了说明，系统由安全的隔间构成，所以如果有组件失效那么其余组件不受影响。这防止了[雪崩问题](http://en.wikipedia.org/wiki/Cascading_failure)并且允许以隔离的方式管理失效。

![fig 3 隔间](images/tank.png)

事件驱动模型使可伸缩性变为可能，它也具有实现失效管理所必须的服务原语。事件驱动模型中松藕合完全隔离开组件，模型中的失效能和其上下文——封装成消息——一起被捕获，发给那些监控错误并能决定如何处理错误的其他组件。

这种方法创建的系统，业务逻辑保持得很整洁，业务与失效处理隔离开来，为了对失效以声明方式进行隔离、监控、管理和配置，失效需要被显式建模，同时系统可自愈和自动恢复。如果隔间以层次的结构组织，那么这种办法可完美工作。很像一间大公司，升级问题直到一个具有处理问题能力的层级。

这种模式之美在于，它是纯事件驱动的，基于反应式组件和异步事件。因而是地域透明的。在实践中，这意味着它在分布式和本地环境中工作方式完全相同，也意味着在协作的组件之间传递的消息可以被很容易地存储和重放，即使在严重的宕机以后，或者在系统适当修复以后，或者接入新地域备份的消息存储以后，应用也具有平滑恢复处理的能力。

##快速响应的
###为什么重要？
Merrian-Webster定义“响应的”是，*“恰当的快速响应或反应”*。我们在一般意义上使用这个词，不应把它和[响应式WEB设计](http://en.wikipedia.org/wiki/Responsive_Web_Design)，(主要指CSS媒介查询和阶段性增强）混淆起来。

快速响应的应用是实时的、迷人的、丰富的并且也是合作的。业务创建了与用户开放和持续的对话渠道，以快速交互体验迎接用户。这使用户更高效，创建了一种体验，让用户感觉和应用连接起来、应用是解决问题的好装备，以及应用能够完成任务。一个例子是，GOOGLE DOCS以实时方式——允许人们实时看到其他人所做的修改，使用户能协作编辑文档。

即使有失效发生，应用也需要以及时的方式响应事件。如果应用不在可接受时间内响应——称为时延过大——那它就真是不可用的。

对某些应用来说，如武器或医疗控制系统，不能满足严苛的实时需求就等同于系统失效。不是所有应用都有如此严格的实时需求。许多应用程序一旦偏离响应约定则其使用率会降低，比如没有及时响应的话，财务商务应用会失掉嘴边的生意。

更多主流的应用，如浏览和购买零售商品，响应时间拉长时显示出可观的使用率下降。用户只和快速的应用交互，其结果当然是更大的购买量。

###关键构件
反应式应用使用观察者模式、事件流和有状态的客户端。

观察者模式使其他系统在状态变更时收到事件。这可以为用户和系统间提供实时连接。举例来说，当大量用户在同一模型上并发工作时，在他们之间及时反应出双向同步，因而模型就像无锁而共享。

连接是建立在事件流之上的基本抽象。保持对事件的反应意味着允许异步和非阻塞变换与通信而避免阻塞。

反应式应用主动拥抱了[算法的复杂度](http://en.wikipedia.org/wiki/Big_O_notation)，通过使用设计模式和测试，确保无论负载如何，事件响应的时间复杂度为O(1)或最小值O(log n)。伸缩因素包含但不限于用户、会话、产品和交易。

无论负载属性如何，反应式应用使用一些策略保持时延不变：
- 在突发流量条件下，反应式应用分期消化高成本操作——如IO和并发数据交换——结合对重要资源的理解和考虑，使用批量合并，来保持一致的时延。
- 根据恰当的后台压力使用有界的队列，给定响应约定下的队列的长度可以用[里特定律](http://en.wikipedia.org/wiki/Little's_law)确定。
- 系统根据适当容量计划监控起来。
- 一旦[断路器](http://en.wikipedia.org/wiki/Circuit_breaker_design_pattern)被触发，要用快速可用的备用策略把失效隔离开来。
- 支撑降级服务响应所需的资源，要和系统其余在高负载条件下提供及时响应的部分隔离开来。

快速响应的应用的一个例子是，一个有各种客户端（浏览器或移动应用）的web应用程序，要创建迷人的用户体验。该应用将执行逻辑并在客户端保存状态，观察者模式提供了数据变更时同步更新UI的机制。像WebSockets这样的技术或服务端事件，使得UI和推送的事件流直接相连。因此事件驱动从系统的后台到客户端全方位扩展。这允许反应式应用通过使用异步和非阻塞数据交换，以可伸缩的和弹性的方式，推送事件给浏览器和移动应用。

注意，四大特质——*事件驱动*、*可伸缩*、*弹性*和*快速响应*——是一个有机结合的整体。

![fig 4. 快速反应的特性](images/full-reactive.png)

##结论
反应式应用代表了一种平衡的办法，解决当代软件开发领域广泛的挑战。构建一个*事件驱动的*、基于消息的基础，反应式应用提供一组确保*可伸缩性*和*弹性*所需的工具。基于此，反应式应用支持丰富的、*快速响应的*用户交互。展望未来，我们期望遵循这一蓝图的系统数量快速增长。

[签署宣言](http://www.reactivemanifesto.org/)

